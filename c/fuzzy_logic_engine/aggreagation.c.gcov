        -:    0:Source:aggreagation.c
        -:    0:Programs:7
        -:    1:#include "cstring.h"
        -:    2:#include "clist.h"
        -:    3:#include "cdict.h"
        -:    4:#include "aggreagation.h"
        -:    5:#include <stdio.h>
        -:    6:#include <stdlib.h>
        -:    7:#include <time.h>
        -:    8:
    #####:    9:float ArrayMax( float * values, int len )
        -:   10:{
    #####:   11:    float maxValue = values[0];
    #####:   12:    int i = 0;
        -:   13:
    #####:   14:    while ( i < len )
        -:   15:    {
    #####:   16:        if ( values[i] > maxValue )
    #####:   17:            maxValue = values[i];
    #####:   18:        i++;
        -:   19:    }
        -:   20:
    #####:   21:    return maxValue;
        -:   22:}
        -:   23:
    #####:   24:float ArrayMin( float * values, int len )
        -:   25:{
    #####:   26:    float minValue = values[0];
    #####:   27:    int i = 0;
        -:   28:
    #####:   29:    while ( i < len )
        -:   30:    {
    #####:   31:        if ( values[i] < minValue )
    #####:   32:            minValue = values[i];
    #####:   33:        i++;
        -:   34:    }
        -:   35:
    #####:   36:    return minValue;
        -:   37:}
        -:   38:
    #####:   39:float ArraySum( float * values, int len )
        -:   40:{
    #####:   41:    int i = 0;
    #####:   42:    float result = 0;
        -:   43:
    #####:   44:    for ( i = 0; i < len; i++ )
    #####:   45:        result += values[i];
        -:   46:
    #####:   47:    return result;
        -:   48:}
        -:   49:
    #####:   50:float ArrayMul( float * values, int len )
        -:   51:{
    #####:   52:    int i = 0;
    #####:   53:    float result = 1;
        -:   54:
    #####:   55:    for ( i = 0; i < len; i++ )
    #####:   56:        result *= values[i];
        -:   57:
    #####:   58:    return result;
        -:   59:}
        -:   60:
    #####:   61:float RandomChoice( float * values, int len )
        -:   62:{
    #####:   63:    srand((unsigned)time(NULL));
    #####:   64:    return values[ rand() % len ];
        -:   65:}
        -:   66:
    #####:   67:char * getTypeOfAggregate( Aggregate * self )
        -:   68:{
    #####:   69:    switch (self->kind)
        -:   70:    {
    #####:   71:    case 0:
    #####:   72:        return NULL;
    #####:   73:    case 1:
    #####:   74:        return "AggregateMin()";
        -:   75:        break;
    #####:   76:    case 2:
    #####:   77:        return "AggregateMax()";
        -:   78:        break;
    #####:   79:    case 3:
    #####:   80:        return "AggregateAvarage()";
        -:   81:        break;
    #####:   82:    case 4:
    #####:   83:        return "AggregateRandom()";
        -:   84:        break;
    #####:   85:    default:
    #####:   86:        return NULL;
        -:   87:    }
        -:   88:}
        -:   89:
    #####:   90:Aggregate * InitAggregate( int kind )
        -:   91:{
    #####:   92:    Aggregate * self = malloc( sizeof(Aggregate) );
    #####:   93:    self->kind = kind;
    #####:   94:    switch (self->kind)
        -:   95:    {
    #####:   96:    case 0:
    #####:   97:        break;
    #####:   98:    case 1:
        -:   99:    {
    #####:  100:        char * source1 = "Set Degree of consequent as the minimum between the degrees of truth of antecedents";
        -:  101:
    #####:  102:        cstring * str1 = NULL;
    #####:  103:        int i1 = 0;
    #####:  104:        snode * sptr1 = NULL;
    #####:  105:        snode * cur1 = NULL;
        -:  106:
    #####:  107:        str1 = malloc( sizeof(cstring) );
    #####:  108:        if ( source1 == NULL )
        -:  109:        {
    #####:  110:            str1->first = NULL;
    #####:  111:            str1->count = 0;
        -:  112:        }
        -:  113:        else
        -:  114:        {
    #####:  115:            sptr1 = InitSnode(source1[0]);
    #####:  116:            str1->first = cur1 = sptr1;
    #####:  117:            for ( i1 = 1; source1[i1] != '\0'; i1++ )
        -:  118:            {
    #####:  119:                sptr1 = InitSnode(source1[i1]);
    #####:  120:                cur1->next = sptr1;
    #####:  121:                cur1 = sptr1;
        -:  122:            }
    #####:  123:            str1->count = i1;
        -:  124:        }
        -:  125:
    #####:  126:        self->description = str1;
    #####:  127:        break;
        -:  128:    }
    #####:  129:    case 2:
        -:  130:    {
    #####:  131:        char * source2 = "Set Degree of consequent as the maximum between the degrees of truth of antecedents";
        -:  132:
    #####:  133:        cstring * str2 = NULL;
    #####:  134:        int i2 = 0;
    #####:  135:        snode * sptr2 = NULL;
    #####:  136:        snode * cur2 = NULL;
        -:  137:
    #####:  138:        str2 = malloc( sizeof(cstring) );
    #####:  139:        if ( source2 == NULL )
        -:  140:        {
    #####:  141:            str2->first = NULL;
    #####:  142:            str2->count = 0;
        -:  143:        }
        -:  144:        else
        -:  145:        {
    #####:  146:            sptr2 = InitSnode(source2[0]);
    #####:  147:            str2->first = cur2 = sptr2;
    #####:  148:            for ( i2 = 1; source2[i2] != '\0'; i2++ )
        -:  149:            {
    #####:  150:                sptr2 = InitSnode(source2[i2]);
    #####:  151:                cur2->next = sptr2;
    #####:  152:                cur2 = sptr2;
        -:  153:            }
    #####:  154:            str2->count = i2;
        -:  155:        }
        -:  156:
    #####:  157:        self->description = str2;
    #####:  158:        break;
        -:  159:    }
    #####:  160:    case 3:
        -:  161:    {
    #####:  162:        char * source3 = "Set Degree of consequent as the avarage of the degrees of truth of antecedents";
        -:  163:
    #####:  164:        cstring * str3 = NULL;
    #####:  165:        int i3 = 0;
    #####:  166:        snode * sptr3 = NULL;
    #####:  167:        snode * cur3 = NULL;
        -:  168:
    #####:  169:        str3 = malloc( sizeof(cstring) );
    #####:  170:        if ( source3 == NULL )
        -:  171:        {
    #####:  172:            str3->first = NULL;
    #####:  173:            str3->count = 0;
        -:  174:        }
        -:  175:        else
        -:  176:        {
    #####:  177:            sptr3 = InitSnode(source3[0]);
    #####:  178:            str3->first = cur3 = sptr3;
    #####:  179:            for ( i3 = 1; source3[i3] != '\0'; i3++ )
        -:  180:            {
    #####:  181:                sptr3 = InitSnode(source3[i3]);
    #####:  182:                cur3->next = sptr3;
    #####:  183:                cur3 = sptr3;
        -:  184:            }
    #####:  185:            str3->count = i3;
        -:  186:        }
        -:  187:
    #####:  188:        self->description = str3;
    #####:  189:        break;
        -:  190:    }
    #####:  191:    case 4:
        -:  192:    {
    #####:  193:        char * source4 = "Set Degree of consequent using one of the values in the vector";
        -:  194:
    #####:  195:        cstring * str4 = NULL;
    #####:  196:        int i4 = 0;
    #####:  197:        snode * sptr4 = NULL;
    #####:  198:        snode * cur4 = NULL;
        -:  199:
    #####:  200:        str4 = malloc( sizeof(cstring) );
    #####:  201:        if ( source4 == NULL )
        -:  202:        {
    #####:  203:            str4->first = NULL;
    #####:  204:            str4->count = 0;
        -:  205:        }
        -:  206:        else
        -:  207:        {
    #####:  208:            sptr4 = InitSnode(source4[0]);
    #####:  209:            str4->first = cur4 = sptr4;
    #####:  210:            for ( i4 = 1; source4[i4] != '\0'; i4++ )
        -:  211:            {
    #####:  212:                sptr4 = InitSnode(source4[i4]);
    #####:  213:                cur4->next = sptr4;
    #####:  214:                cur4 = sptr4;
        -:  215:            }
    #####:  216:            str4->count = i4;
        -:  217:        }
        -:  218:
    #####:  219:        self->description = str4;
    #####:  220:        break;
        -:  221:    }
    #####:  222:    default:
    #####:  223:        printf("ERROR!");
    #####:  224:        exit(0);
        -:  225:    }
    #####:  226:    return self;
        -:  227:}
        -:  228:
    #####:  229:void FreeAggregate( Aggregate * self )
        -:  230:{
    #####:  231:    if ( self != NULL )
        -:  232:    {
    #####:  233:        FreeCstring(&(self->description));
    #####:  234:        free(self);
    #####:  235:        self = NULL;
        -:  236:    }
    #####:  237:    return ;
        -:  238:}
        -:  239:
    #####:  240:float __call__Aggregate( Aggregate * self, float * vector, int len )
        -:  241:{
    #####:  242:    float result = 0;
        -:  243:
    #####:  244:    switch (self->kind)
        -:  245:    {
    #####:  246:    case 0:
    #####:  247:        result = -1;
    #####:  248:        break;
    #####:  249:    case 1:
    #####:  250:        result = ArrayMin( vector, len );
    #####:  251:        break;
    #####:  252:    case 2:
    #####:  253:        result = ArrayMax( vector, len );
    #####:  254:        break;
    #####:  255:    case 3:
    #####:  256:        result = ArraySum( vector, len ) / len;
    #####:  257:        break;
    #####:  258:    case 4:
    #####:  259:        result = RandomChoice( vector, len );
    #####:  260:        break;
    #####:  261:    default:
    #####:  262:        printf("ERROR!");
    #####:  263:        exit(0);
        -:  264:    }
        -:  265:
    #####:  266:    return result;
        -:  267:}
        -:  268:
    #####:  269:char * __str__Aggregate( Aggregate * self )
        -:  270:{
    #####:  271:    switch (self->kind)
        -:  272:    {
    #####:  273:    case 0:
    #####:  274:        return NULL;
    #####:  275:    case 1:
    #####:  276:        return "AggregateMin(): Set Degree of consequent as the minimum between the degrees of truth of antecedents";
        -:  277:        break;
    #####:  278:    case 2:
    #####:  279:        return "AggregateMax(): Set Degree of consequent as the maximum between the degrees of truth of antecedents";
        -:  280:        break;
    #####:  281:    case 3:
    #####:  282:        return "AggregateAvarage(): Set Degree of consequent as the avarage of the degrees of truth of antecedents";
        -:  283:        break;
    #####:  284:    case 4:
    #####:  285:        return "AggregateRandom(): Set Degree of consequent using one of the values in the vector";
        -:  286:        break;
    #####:  287:    default:
    #####:  288:        return NULL;
        -:  289:    }
        -:  290:}
