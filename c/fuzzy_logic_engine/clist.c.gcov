        -:    0:Source:clist.c
        -:    0:Programs:7
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include "clist.h"
        -:    4:#include "cstring.h"
        -:    5:
        -:    6:#define FLT_MAX         3.402823466e+38F
        -:    7:
       18:    8:inode * InitInode( float number )
        -:    9:{
       18:   10:    inode * iptr = malloc( sizeof(inode) );
       18:   11:    iptr->next = NULL;
       18:   12:    iptr->number = number;
        -:   13:
       18:   14:    return iptr;
        -:   15:}
        -:   16:
    #####:   17:void FreeInode( inode * iptr )
        -:   18:{
    #####:   19:    free(iptr);
    #####:   20:    iptr = NULL;
    #####:   21:}
        -:   22:
    #####:   23:void AddInode( clist * self, inode * iptr )
        -:   24:{
    #####:   25:    inode * cur = NULL;
        -:   26:
    #####:   27:    cur = self->first;
    #####:   28:    if ( cur == NULL )
        -:   29:    {
    #####:   30:        self->first = iptr;
    #####:   31:        self->count++;
    #####:   32:        return ;
        -:   33:    }
    #####:   34:    while ( cur->next != NULL )
    #####:   35:        cur = cur->next;
    #####:   36:    cur->next = iptr;
    #####:   37:    self->count++;
        -:   38:}
        -:   39:
        7:   40:clist * InitClist( float * values, int count )
        -:   41:{
        7:   42:    clist * cptr = NULL;
        7:   43:    int i = 0;
        -:   44:
        7:   45:    cptr = malloc( sizeof(clist) );
        7:   46:    cptr->first = NULL;
        7:   47:    cptr->count = 0;
        7:   48:    if ( count > 0 )
        9:   49:        for ( i = 0; i < count; i++ )
        7:   50:            ClistAppend( cptr, values[i] );
        -:   51:
        7:   52:    return cptr;
        -:   53:}
        -:   54:
    #####:   55:void FreeClist( clist * cptr )
        -:   56:{
    #####:   57:    inode * sptr = NULL;
    #####:   58:    inode * next = NULL;
        -:   59:
    #####:   60:    if ( cptr != NULL )
        -:   61:    {
    #####:   62:        sptr = cptr->first;
    #####:   63:        while ( sptr != NULL )
        -:   64:        {
    #####:   65:            next = sptr->next;
    #####:   66:            FreeInode(sptr);
    #####:   67:            sptr = next;
        -:   68:        }
    #####:   69:        free(cptr);
    #####:   70:        cptr = NULL;
        -:   71:    }
    #####:   72:    return ;
        -:   73:}
        -:   74:
        3:   75:void SetClist( clist ** target, clist * source )
        -:   76:{
        3:   77:    inode * cur = NULL;
        3:   78:    int count = source->count;
        -:   79:
        3:   80:    if ( count == 0 )
    #####:   81:        return ;
        3:   82:    if ( *target == source )
    #####:   83:        return ;
        3:   84:    *target = InitClist( NULL, 0 );
       14:   85:    for ( cur = source->first; cur != NULL; cur = cur->next )
       11:   86:        ClistAppend( *target, cur->number );
        -:   87:}
        -:   88:
       18:   89:void ClistAppend( clist * List, float number )
        -:   90:{
       18:   91:    inode * iptr = NULL;
       18:   92:    inode * cur = NULL;
        -:   93:
       18:   94:    iptr = InitInode( number );
       18:   95:    cur = List->first;
       18:   96:    if ( cur == NULL )
        5:   97:        List->first = iptr;
        -:   98:    else
        -:   99:    {
       24:  100:        for ( ; cur->next != NULL; cur = cur->next );
       13:  101:        cur->next = iptr;
        -:  102:    }
       18:  103:    List->count++;
       18:  104:}
        -:  105:
    #####:  106:inode * ClistDel( clist * list, int place )
        -:  107:{
    #####:  108:    inode * cur = NULL;
    #####:  109:    int length = -1;
    #####:  110:    int i = 1;
    #####:  111:    inode * iptr = NULL;
    #####:  112:    inode * tmpNode = NULL;
        -:  113:
    #####:  114:    if ( list == NULL )
    #####:  115:        return NULL;
        -:  116:
    #####:  117:    cur = list->first;
    #####:  118:    length = list->count;
    #####:  119:    if ( cur == NULL )
    #####:  120:        return NULL;
    #####:  121:    if ( length < place )
    #####:  122:        return NULL;
        -:  123:
    #####:  124:    if ( place == 1 )
        -:  125:    {
    #####:  126:        tmpNode = cur->next;
    #####:  127:        cur->next = NULL;
    #####:  128:        list->first = tmpNode;
    #####:  129:        list->count -= 1;
    #####:  130:        return cur;
        -:  131:    }
    #####:  132:    while ( i + 1 < place )
        -:  133:    {
    #####:  134:        cur = cur->next;
    #####:  135:        i++;
        -:  136:    }
    #####:  137:    tmpNode = cur->next;
    #####:  138:    cur->next = tmpNode->next;
    #####:  139:    tmpNode->next = NULL;
    #####:  140:    iptr = tmpNode;
    #####:  141:    list->count -= 1;
    #####:  142:    return iptr;
        -:  143:}
        -:  144:
    #####:  145:void ClistSort( clist * List )
        -:  146:{
    #####:  147:    int count = List->count;
    #####:  148:    inode * i1 = NULL;
    #####:  149:    inode * i2 = NULL;
    #####:  150:    inode * i3 = NULL;
    #####:  151:    inode * i4 = NULL;
    #####:  152:    int i = 0;
    #####:  153:    int j = 0;
    #####:  154:    int k = 0;
    #####:  155:    float temp = 0;
    #####:  156:    float array[4] = { 0, 0, 0, 0 };
    #####:  157:    int maxi = 3;
    #####:  158:    int maxj = 4;
        -:  159:
    #####:  160:    switch ( count )
        -:  161:    {
    #####:  162:    case 2:
    #####:  163:        i1 = List->first;
    #####:  164:        i2 = i1->next;
    #####:  165:        if ( i1->number > i2->number )
        -:  166:        {
    #####:  167:            temp = i1->number;
    #####:  168:            i1->number = i2->number;
    #####:  169:            i2->number = temp;
        -:  170:        }
    #####:  171:        break;
    #####:  172:    case 3:
    #####:  173:        i1 = List->first;
    #####:  174:        i2 = i1->next;
    #####:  175:        i3 = i2->next;
    #####:  176:        if ( i1->number > i2->number )
        -:  177:        {
    #####:  178:            temp = i1->number;
    #####:  179:            i1->number = i2->number;
    #####:  180:            i2->number = temp;
        -:  181:        }
    #####:  182:        if ( i1->number > i3->number )
        -:  183:        {
    #####:  184:            temp = i1->number;
    #####:  185:            i1->number = i3->number;
    #####:  186:            i3->number = temp;
        -:  187:        }
    #####:  188:        if ( i2->number > i3->number )
        -:  189:        {
    #####:  190:            temp = i2->number;
    #####:  191:            i2->number = i3->number;
    #####:  192:            i3->number = temp;
        -:  193:        }
    #####:  194:        break;
    #####:  195:    case 4:
    #####:  196:        i1 = List->first;
    #####:  197:        i2 = i1->next;
    #####:  198:        i3 = i2->next;
    #####:  199:        i4 = i3->next;
    #####:  200:        array[0] = i1->number;
    #####:  201:        array[1] = i2->number;
    #####:  202:        array[2] = i3->number;
    #####:  203:        array[3] = i4->number;
    #####:  204:        for ( i = 0; i < maxi; i++ )
        -:  205:        {
    #####:  206:            k = i;
    #####:  207:            temp = array[i];
    #####:  208:            for ( j = i; j < maxj; j++ )
    #####:  209:                if ( temp > array[j] )
        -:  210:                {
    #####:  211:                    temp = array[j];
    #####:  212:                    k = j;
        -:  213:                }
    #####:  214:            array[k] = array[i];
    #####:  215:            array[i] = temp;
    #####:  216:            i1->number = array[0];
    #####:  217:            i2->number = array[1];
    #####:  218:            i3->number = array[2];
    #####:  219:            i4->number = array[3];
        -:  220:        }
    #####:  221:        break;
    #####:  222:    default:
    #####:  223:        printf("ERROR!\n");
    #####:  224:        exit(0);
        -:  225:    }
    #####:  226:}
        -:  227:
        2:  228:float ClistMax( clist * List )
        -:  229:{
        2:  230:    inode * cur = List->first;
        2:  231:    float maxValue = 0;
        2:  232:    float curNumber = 0;
        -:  233:
        2:  234:    if ( cur == NULL )
    #####:  235:        return -1;
        2:  236:    maxValue = cur->number;
       16:  237:    while ( cur != NULL )
        -:  238:    {
        7:  239:        curNumber = cur->number;
        7:  240:        if ( maxValue < curNumber )
        5:  241:            maxValue = cur->number;
        7:  242:        cur = cur->next;
        -:  243:    }
        -:  244:
        2:  245:    return maxValue;
        -:  246:}
        -:  247:
        2:  248:float ClistMin( clist * List )
        -:  249:{
        2:  250:    inode * cur = List->first;
        2:  251:    float minValue = 0;
        2:  252:    float curNumber = 0;
        -:  253:
        2:  254:    if ( cur == NULL )
    #####:  255:        return -1;
        2:  256:    curNumber = cur->number;
        2:  257:    minValue = cur->number;
       16:  258:    while ( cur != NULL )
        -:  259:    {
        7:  260:        if ( minValue > cur->number )
    #####:  261:            minValue = cur->number;
        7:  262:        cur = cur->next;
        -:  263:    }
        -:  264:
        2:  265:    return minValue;
        -:  266:}
        -:  267:
        7:  268:float GetInodeNum( clist * self, int key )
        -:  269:{
        7:  270:    inode * cur = self->first;
        7:  271:    int i = 0;
        7:  272:    float curNumber = 0;
        -:  273:
       16:  274:    for ( i = 0; i < key; i++ )
        9:  275:        cur = cur->next;
        7:  276:    curNumber = cur->number;
        7:  277:    return curNumber;
        -:  278:}
        -:  279:
        2:  280:char * GetClist( clist * self )
        -:  281:{
        2:  282:    cstring * cstr = InitCstring( "[" );
        2:  283:    char * str = NULL;
        2:  284:    int i = 0;
        2:  285:    int count = self->count;
        2:  286:    int commaPlace = 0;
        -:  287:
        9:  288:    for ( i = 0; i < count; i++ )
        -:  289:    {
        7:  290:        Cstradd( &cstr, NumtoStr( GetInodeNum( self, i ) ) );
        7:  291:        commaPlace = count - 1;
        7:  292:        if ( i < commaPlace )
        5:  293:            Cstradd( &cstr, ", " );
        -:  294:    }
        2:  295:    Cstradd( &cstr, "]" );
        2:  296:    str = CstrtoStr( cstr );
        2:  297:    FreeCstring( &cstr );
        2:  298:    return str;
        -:  299:}
        -:  300:
    #####:  301:float Sum( clist * List )
        -:  302:{
    #####:  303:    inode * iptr = NULL;
    #####:  304:    float result = 0;
    #####:  305:    float iptrNumber = 0;
        -:  306:
    #####:  307:    for ( iptr = List->first; iptr != NULL; iptr = iptr->next )
        -:  308:    {
    #####:  309:        iptrNumber = iptr->number;
    #####:  310:        result += iptrNumber;
        -:  311:    }
        -:  312:
    #####:  313:    return result;
        -:  314:}
        -:  315:
    #####:  316:float Mul( clist * List )
        -:  317:{
    #####:  318:    inode * iptr = NULL;
    #####:  319:    float result = 1;
    #####:  320:    float iptrNumber = 0;
        -:  321:
    #####:  322:    for ( iptr = List->first; iptr != NULL; iptr = iptr->next )
        -:  323:    {
    #####:  324:        iptrNumber = iptr->number;
    #####:  325:        result *= iptrNumber;
        -:  326:    }
        -:  327:
    #####:  328:    return result;
        -:  329:}
        -:  330:
    #####:  331:float MulSum( clist * List1, clist * List2 )
        -:  332:{
    #####:  333:    inode * i1ptr = NULL;
    #####:  334:    inode * i2ptr = NULL;
    #####:  335:    float temp = 0;
    #####:  336:    float result = 0;
        -:  337:
    #####:  338:    for ( i1ptr = List1->first, i2ptr = List2->first; i1ptr != NULL && i2ptr != NULL; i1ptr = i1ptr->next, i2ptr = i2ptr->next )
        -:  339:    {
    #####:  340:        temp = i1ptr->number * i2ptr->number;
    #####:  341:        result += temp;
        -:  342:    }
        -:  343:
    #####:  344:    return result;
        -:  345:}
        -:  346:
    #####:  347:float SumMul( clist * List1, clist * List2 )
        -:  348:{
    #####:  349:    inode * i1ptr = NULL;
    #####:  350:    inode * i2ptr = NULL;
    #####:  351:    float temp = 0;
    #####:  352:    float result = 1;
        -:  353:
    #####:  354:    for ( i1ptr = List1->first, i2ptr = List2->first; i1ptr != NULL && i2ptr != NULL; i1ptr = i1ptr->next, i2ptr = i2ptr->next )
        -:  355:    {
    #####:  356:        temp = i1ptr->number + i2ptr->number;
    #####:  357:        result *= temp;
        -:  358:    }
        -:  359:
    #####:  360:    return result;
        -:  361:}
